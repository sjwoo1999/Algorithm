function solution(n) {
    let memo = [0, 1];

    function fibo(n) {
        for(let i = 2; i <= n; i++) {
            memo[i] = (memo[i - 1] + memo[i - 2]) % 1234567;
        }
    
        return memo[n];
    }
    
    return fibo(n);
}

// 반복문
// : 중복 계산 없이, 한번 계산한 값을 배열에 저장하여 재사용하기 때문에
// : 시간복잡도가 O(n)이 되고,

// 재귀
// : 재귀 호출에 의해 함수가 여러 번 호출되기 때문에
// : 시간 복잡도는 O(2^n)이라고 한다.

// 메모이제이션 + 재귀
// : 1) 이미 계산한 값인지 확인하고,
// : 2) 이미 계산한 값이라면 해당 값을 재사용하기 때문에
// : 중복 계산을 피할 수 있으므로 O(n)의 시간복잡도가 걸린다.
// : 하지만 재귀 호출에 따른 함수 호출 비용이 증가하기 때문에
// : 결론적으로 반복문보다는 오래 걸린다.

// 따라서 반복문을 이용한 풀이가 재귀 & 메모이제이션을 이용한 알고리즘보다
// 효율적이며 더 빠른 실행 속도를 가지게 된다.